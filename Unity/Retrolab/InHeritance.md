# 상속

상속 다형성 

상속은 베이스 클래스를 가지고와서 사용해서 코드 재활용 



다형성이란 베이트 클래스에서 파생 클래스를 한번에 관리한다.



예시를 보자



프로젝트 만들자 C# 스크립트



애니몰 만들자 간단한 예제를 하기위해 monobe 제거



mono도 상속인데 이것을 지워주자



동물 클래스를 만들어보자



모든 친구들의 공통 기능을 가져와서 고양이나 개를 만들자

이름, 몸무게 , 년도

동물이 스스로의 정보를 뛰우도록 한다.



print 메소드로 몸무게 나이를 찍어보자



새로운 함수를 만들어서 동물의 속도 



나이에 따라 속도가 줄어듬 

100f/(weight * year)



기본적인 에니멀 클래스를 만들었다.



이것을 바탕으로 개를 만들어보자

사냥하는 기능을 넣어보자

Animal을 바닥에 깔아놓고 진행한다. Animal 모든 기능을 가져다 쓸 수 있다.

Mono 모든 기능을 가져올 수 있는것이랄ㅇ 같다



사냥 메소드를 만들자

publci void Hunt()

{	float speed = GetSpeed();

}

저는 GetSpeed를 만들지 않았지만, Animal에 구현했기 때문에 사용가능



사냥이 끝나면 몸무게를 증가한다. 몸무게 변수 만들 필요없지..



이제 고양이를 만들어보자

숨는 기능을 추가 해보자

Stealth 미리 만들어져 있는 코드를 가져와서 재활용하자



테스트 해보자



프로젝트 빈공간에 C#스크립트를 만들어서 



Test 스크립트에서 게임이 시작됐을 때 Cat, Dog를 만들자

new Cat는 메모리에 찍어낸다고 했죠??

변수 초기화 해주자\

개도 찍어내자

이상태에서 고유 기능을  하고 상속 받은 기능도 사용가능



jack도 잭만에 함수 하고 애니멀 함수도 사용가능합니다.



새로운 빈게임 오브젝트 만들어서 Test 를 추가해서

확인



그런데 자식클래스는 부모클래스것을 가져올 수 있는데,  쓸수 있는지 쓸수 없는지 지정할 수 있어.

스피드를 가져와야 하긴하는데, 부모클래스 에서 어떻게 구현했는지 알필요 없지



private float calcSpeed()

에 계산 로직을 넣으면



Dog쪽에서 Calc를 확인 할 수 없어

자식이 알필요 없는 정보를 닫을 수 있다.



또 외부에서는 사용하지 못하게하고 싶은데, 자식들은 쓸 수 있게하고 싶어

그게 protected 키워드입니다.



자식들은 가져다 쓸 수 있지만 바깥에서 접근



결론 코드를 밖에서 봤을 때 봤을 때 간결하게 보이게 하기 위해서,





### 다형성

기본 형태에서 파생된 형태를 기본형태로써 실행하는 것이다.

집합을 보면 생명이라는 집합은

숨을 쉰다라는 조건이 있다.

​	 생명

동물 ,  식물



생명이 범위가 젤크지 동물에는 숨을 쉰다 조건이 있다. , 움직인다 

식물은 숨을 쉰다 , 안움직인다 라는 조건



생명보다 조건이 많다. 즉 조건이 많을 수 록 작은 집합이다.



큰집합은 작은 집합과 일치한다고 볼 수 없다.



큰집합은 조건이 별로 없다.



내부 구현이 많을 수록 좁아진다. 이것이 다형성을 이해하는데 좋음



dog , cat은 애니멀이 될 수있지만 애니멀은 dog ,cat이 될 수없다



코드 보면



dog,cat은 애니멀로 가져올 수 있다.

Animal somAnimal = jack;//공통적인 Animal로 Dog, cat을 가져 올 수 있다. 하지만 고유 기능을 사용할 수 없다.

somAnimal .print(); //공유 기능은 사용가능 고유 변수 함수가 날아 가는게 아니고 가지고 있지만 애니멀로 가지고 있어서 사용못하는 것이다.

Dog myDog = (Dog)someAnimal; // 캐스트로 변환하면 고유 기능 사용가능한다.

하지만 자식 클래스 고유기능 사용못한다.



이렇게 되면 일일이 기린 코끼리 선언해서 가져올 ㅅ필요없지 애니멀이라는 공통 부분이 있기 때문에,

Animal[] animals = new Animal[2];

animals[0] = nate;

animals[1] = jack;



for (int i = 0 ; i < animals.Length; i++)

{

​	animals[i].Print();

​	//animals[i].Stealth();//사용불가

}

하지만 이렇게 여러 타입을  한번에 가져와서 처리가 가능하다 이제 다형성이 특징



monobehavier를 상속받으면 해당 기능을 사용할 수 있지 그래서 해당 component 를 사용할 수 있고ㅓ,

부품으로서 붙일 수 있는 거임